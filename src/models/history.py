"""This file defines the history model for the application.
It includes classes for Genre, Price, and Hardware.
Each class has its own validation methods to ensure the data integrity.
For example, the Price class checks if the low price is less than or equal to the high price.
"""
import re
from typing import Annotated, ClassVar, Self

import pydantic
import sqlmodel

from models import account, custom_pydantic


class Genre(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the genre. This class is used to validate the input values."""

    genre: Annotated[str, pydantic.AfterValidator(custom_pydantic.validate_genre)]


class Price(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the price. This class is used to validate the input values."""

    low_price: int = pydantic.Field(ge=0, le=10000, multiple_of=1000)
    high_price: int = pydantic.Field(ge=0, le=10000, multiple_of=1000)

    @pydantic.model_validator(mode="after")
    def validate_price(self) -> Self:
        """Validates the price.

        This method checks if the low price is less than or equal to the high price.

        Returns:
            Self: An instance of the class.

        Raises:
            ValueError: If the low price is greater than the high price.
        """
        if self.low_price > self.high_price:
            raise ValueError("最低価格は最高価格以下である必要があります")
        return self

    @property
    def price(self) -> str:
        """Returns the price.

        Returns:
            str: The price.
        """
        return f"{self.low_price}円 ~ {self.high_price}円"


class Hardware(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the hardware. This class is used to validate the input values."""

    hardware: Annotated[str, pydantic.AfterValidator(custom_pydantic.validate_hardware)]


class GameFormat(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the game format. This class is used to validate the input values."""

    game_format: Annotated[str, pydantic.AfterValidator(custom_pydantic.validate_game_format)]


class WorldView(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the world view. This class is used to validate the input values."""

    world_view: Annotated[str, pydantic.AfterValidator(custom_pydantic.validate_world_view)]


class Detail(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the detail. This class is used to validate the input values."""

    detail: str = pydantic.Field(max_length=1000)


class RecommendedGame(custom_pydantic.FrozenBaseModel):
    """Wrapper class for the recommended game. This class is used to validate the input values."""

    recommended_game: str = pydantic.Field(max_length=100)

    @classmethod
    def from_text(cls, recommended_text: str) -> Self:
        """This class method takes in a string containing the recommended game and returns an instance of the class.

        Args:
            recommended_text (str): A string generated by GPT model.

        Returns:
            Self: An instance of the class.
        """
        match: re.Match[str] | None = re.search(r"推薦ゲーム: ([^\n]*)", recommended_text)
        if match is None:
            raise ValueError(
                """予期せぬエラーが発生しました: おすすめのゲームが見つかりませんでした。
                条件を何も選択していない場合は、条件を選択してください。
                条件を多く選択している場合は、条件を減らしてください。
                """
            )
        return cls(recommended_game=match.group(1))


class History(sqlmodel.SQLModel, table=True):
    """SQL model for the History table. This class should not be used directly."""

    __table_args__: ClassVar = {"extend_existing": True}

    id: int | None = sqlmodel.Field(default=None, primary_key=True)
    user_id: str = sqlmodel.Field(index=True)
    genre: str
    price: str
    hardware: str
    game_format: str
    world_view: str
    detail: str
    recommended_game: str

    @classmethod
    def from_model(
        cls,
        user_id_model: account.UserID,
        genre_model: Genre,
        price_model: Price,
        hardware_model: Hardware,
        game_format_model: GameFormat,
        world_view_model: WorldView,
        detail_model: Detail,
        recommended_game_model: RecommendedGame,
    ) -> Self:
        """This class method takes in instances of UserID, Genre, Price, Hardware, GameFormat, WorldView, Detail,
        RecommendedGame, and returns an instance of the class.

        SQLModel does not support nested models, so this method is used to convert the nested models to a single model.

        Args:
            user_id_model (account.UserID): An instance of UserID.
            genre_model (Genre): An instance of Genre.
            price_model (Price): An instance of Price.
            hardware_model (Hardware): An instance of Hardware.
            game_format_model (GameFormat): An instance of GameFormat.
            world_view_model (WorldView): An instance of WorldView.
            detail_model (Detail): An instance of Detail.
            recommended_game_model (RecommendedGame): An instance of RecommendedGame.

        Returns:
            Self: An instance of the class.
        """
        return cls(
            user_id=user_id_model.user_id,
            genre=genre_model.genre,
            price=price_model.price,
            hardware=hardware_model.hardware,
            game_format=game_format_model.game_format,
            world_view=world_view_model.world_view,
            detail=detail_model.detail,
            recommended_game=recommended_game_model.recommended_game,
        )
